#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"
#include <iostream>
using namespace cv;

bool existencia_racao(char *filename)
{
	bool existe_racao;
	int pixeis_racao;
	int pixeis_tigela;
	Mat src = imread(filename, 1);
	Mat samples(src.rows * src.cols, 3, CV_32F);
	for (int y = 0; y < src.rows; y++)
		for (int x = 0; x < src.cols; x++)
			for (int z = 0; z < 3; z++)
				samples.at<float>(y + x*src.rows, z) = src.at<Vec3b>(y, x)[z];
	int clusterCount = 4;
	Mat labels;
	int attempts = 5;
	Mat centers;
	kmeans(samples, clusterCount, labels, TermCriteria(CV_TERMCRIT_ITER |
	CV_TERMCRIT_EPS, 10000, 0.0001), attempts, KMEANS_PP_CENTERS, centers);
	Mat new_image(src.size(), src.type());
	for (int y = 0; y < src.rows; y++)
		for (int x = 0; x < src.cols; x++){
			int cluster_idx = labels.at<int>(y + x*src.rows, 0);
			new_image.at<Vec3b>(y, x)[0] = centers.at<float>(cluster_idx, 0);
			new_image.at<Vec3b>(y, x)[1] = centers.at<float>(cluster_idx, 1);
			new_image.at<Vec3b>(y, x)[2] = centers.at<float>(cluster_idx, 2);
		}
	imshow("clustered image", new_image);
	imwrite("clustered_image.jpg", new_image);
	Mat img = imread("clustered_image.jpg", 0);
	// Contabilizar quantos pixeis estÃ£o associados ao label da raÃ§Ã£o,
	// e quantos correspondem ao label da tigela
	pixeis_racao = 0;
	pixeis_tigela = 0;
	for (int y = 0; y < src.rows; y++){
		for (int x = 0; x < src.cols; x++){
			int cluster_idx = labels.at<int>(y + x*src.rows, 0);
			if (cluster_idx == 1){ // em vez de 1, usar o label da raÃ§Ã£o
				pixeis_racao++;
			}
			if (cluster_idx == 0){ // em vez de 2, usar o label da tigela
				pixeis_tigela++;
			}
		}
	}
	if ((float)((1.0 * pixeis_racao) / (1.0 * pixeis_tigela) > 0.2)){ // verificar a conversÃ£o
                                                          // para float
		existe_racao = true;
	}
	else
		existe_racao = false;
	Mat cimg;
	Mat thresh = Mat::zeros(img.size(), img.type());
	medianBlur(img, img, 5);
	cvtColor(img, cimg, COLOR_GRAY2BGR);
	std::vector<Vec3f> circles;
	HoughCircles(img, circles, HOUGH_GRADIENT, 1, 500, 100, 30, 200, 450); //
	//change the last two parameters
	// (min_radius & max_radius) to detect larger circles
	for (size_t i = 0; i < circles.size(); i++){
		Vec3i c = circles[i];
		ellipse(cimg, Point(c[0], c[1] * 3 / 4), Size(c[2], c[2] * 3 / 4), 0, 0,
		360, Scalar(0, 255, 0), 3, LINE_AA);
		ellipse(thresh, Point(c[0], c[1] * 3 / 4), Size(c[2], c[2] * 3 / 4), 0, 0,
		360, Scalar(255, 255, 255), -1, LINE_AA);
		circle(cimg, Point(c[0], c[1]), 2, Scalar(0, 255, 0), 3, LINE_AA);
	}
	imshow("detected circles", cimg);
	imshow("threshold img", thresh);
	Mat hist;
	int histSize = 256;
	float range[] = { 0, 256 };
	const float* histRange = { range };
	calcHist(&img, 1, 0, thresh, hist, 1, &histSize, &histRange, true, false);
	// Draw hist
	int hist_w = 512; int hist_h = 400;
	int bin_w = cvRound((double)hist_w / histSize);
	Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));
	/// Normalize the result to [ 0, histImage.rows ]
	normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
	/// Draw for each channel
	for (int i = 1; i < histSize; i++){
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(hist.at<float>(i -
		1))),
		Point(bin_w*(i), hist_h - cvRound(hist.at<float>(i))),
		Scalar(255, 0, 0), 2, 8, 0);
	}
	/// Display
	namedWindow("calcHist Demo", CV_WINDOW_AUTOSIZE);
	imshow("calcHist Demo", histImage);
	std::cout << "Mean intensity is: " << mean(hist) << std::endl;
	waitKey();
	return existe_racao;
}

int main(int argc, char** argv){
		
		bool existencia;
		
		existencia = existencia_racao(argv[1]);
		std::cout << "Existe racao na tigela? " << existencia << std::endl;
		
		return 0;
}